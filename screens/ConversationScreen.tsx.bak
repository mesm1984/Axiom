import React, { useState, useRef, useEffect } from 'react';
import { 
  View, 
  Text, 
  StyleSheet, 
  TextInput, 
  TouchableOpacity, 
  FlatList, 
  KeyboardAvoidingView, 
  Platform, 
  Vibration,
  Animated,
  Image,seState, useRef, useEffect } from 'react';
import { 
  View, 
  Text, 
  StyleShee          console.log('Erreur chargement son (m√©thode 1):', error);
          
          // Si √©chec et que nous sommes sur Android, on essaie sans extension
          if (Platform.OS === 'android') {
            console.log('Essai sans extension sur Android');
            const sound2 = new Sound('orb', Sound.MAIN_BUNDLE, (error2) => { TextInput, 
  TouchableOpacity, 
  FlatList, 
  KeyboardAvoidingView, 
  Platform, 
  Vibration,
  Animated,
  ActivityIndicator
} from 'react-native';
import { useRoute } from '@react-navigation/native';
import Sound from 'react-native-sound';

// Type pour les messages
type Message = {
  id: string;
  text: string;
  sender: 'user' | 'contact';
  timestamp: Date;
  isFile?: boolean;
  fileName?: string;
  fileSize?: string;
  isHighQuality?: boolean;
  sending?: boolean;
  sent?: boolean;
  received?: boolean;
  read?: boolean;
};

const ConversationScreen = () => {
  const [message, setMessage] = useState('');
  const [messages, setMessages] = useState<Message[]>([
    {
      id: '1',
      text: 'Bonjour, comment √ßa va ?',
      sender: 'contact',
      timestamp: new Date(Date.now() - 60000 * 10), // 10 minutes ago
      sent: true,
      received: true,
      read: true,
    },
    {
      id: '2',
      text: 'Tr√®s bien merci, et toi ?',
      sender: 'user',
      timestamp: new Date(Date.now() - 60000 * 5), // 5 minutes ago
      sent: true,
      received: true,
      read: true,
    },
    {
      id: '3',
      text: 'Super ! On se voit demain comme pr√©vu ?',
      sender: 'contact',
      timestamp: new Date(Date.now() - 60000 * 2), // 2 minutes ago
      sent: true,
      received: true,
      read: false,
    },
    {
      id: '4',
      text: 'photo_vacances.jpg',
      sender: 'contact',
      timestamp: new Date(Date.now() - 60000 * 1), // 1 minute ago
      isFile: true,
      fileName: 'photo_vacances.jpg',
      fileSize: '5.2 MB',
      isHighQuality: true,
      sent: true,
      received: true,
      read: false,
    },
  ]);
  
  // R√©f√©rence pour l'animation de vibration
  const animatedValue = useRef(new Animated.Value(0)).current;
  const listRef = useRef<FlatList>(null);
  
  // √âtat pour suivre la derni√®re fois que la fonction Axiom Vibe a √©t√© utilis√©e
  const [lastVibeTime, setLastVibeTime] = useState(0);
  const [vibeCount, setVibeCount] = useState(0);
  const [vibeSound, setVibeSound] = useState<Sound | null>(null);
  const [notificationSound, setNotificationSound] = useState<Sound | null>(null);

  // R√©f√©rence pour l'animation de la fen√™tre
  const windowAnimatedValue = useRef(new Animated.Value(0)).current;

  useEffect(() => {
    // Initialisation des sons avec le bon chemin selon la plateforme
    Sound.setCategory('Playback');
    
    try {
      // Sur Android et iOS, on utilise un nom de fichier unique
      const soundName = Platform.OS === 'android' ? 'orb.mp3' : 'orb.mp3';
      console.log('Chargement du son Orb:', soundName);
      
      // Tentative de chargement avec l'extension .mp3
      const sound1 = new Sound(soundName, Sound.MAIN_BUNDLE, (error) => {
        if (error) {
          console.log(`Erreur chargement ${soundName}:`, error);
          
          // Si √©chec et que nous sommes sur Android, on essaie sans extension
          if (Platform.OS === 'android') {
            console.log('Essai sans extension sur Android');
            const sound2 = new Sound('orb', Sound.MAIN_BUNDLE, (error2) => {
              if (error2) {
                console.log('√âchec chargement sans extension:', error2);
              } else {
                console.log('Son charg√© avec succ√®s (sans extension)');
                sound2.setVolume(1.0);
                setVibeSound(sound2);
              }
            });
          }
        } else {
          console.log('Son charg√© avec succ√®s:', soundName);
          sound1.setVolume(1.0);
          setVibeSound(sound1);
        }
      });
    } catch (e) {
      console.log('Exception g√©n√©rale lors du chargement des sons:', e);
    }

    // Initialisation du son pour les notifications de messages
    try {
      if (Platform.OS === 'android') {
        // Utiliser la m√™me approche que pour le son de vibe
        const msgSound = new Sound('message_notification', Sound.MAIN_BUNDLE, (error) => {
          if (error) {
            console.log('Erreur chargement notification (m√©thode 1):', error);
            
            // Essai 2: Utiliser le nom avec extension
            const msgSound2 = new Sound('message_notification.mp3', Sound.MAIN_BUNDLE, (error2) => {
              if (error2) {
                console.log('Erreur chargement notification (m√©thode 2):', error2);
              } else {
                console.log('Son de notification charg√© avec succ√®s (m√©thode 2)');
                msgSound2.setVolume(0.7);
                setNotificationSound(msgSound2);
              }
            });
          } else {
            console.log('Son de notification charg√© avec succ√®s (m√©thode 1)');
            msgSound.setVolume(0.7);
            setNotificationSound(msgSound);
          }
        });
      } else {
        // Pour iOS
        const msgSound = new Sound('message_notification.mp3', Sound.MAIN_BUNDLE, (error) => {
          if (error) {
            console.log('Erreur lors du chargement du son de notification sur iOS:', error);
            return;
          }
          console.log('Son de notification charg√© avec succ√®s sur iOS');
          msgSound.setVolume(0.7);
          setNotificationSound(msgSound);
        });
      }
    } catch (e) {
      console.log('Exception g√©n√©rale lors du chargement du son de notification:', e);
    }

    return () => {
      // Nettoyage √† la destruction du composant
      if (vibeSound) {
        vibeSound.release();
      }
      if (notificationSound) {
        notificationSound.release();
      }
    };
  }, [vibeSound, notificationSound]);

  // Fonction pour jouer le son de notification
  const playMessageNotificationSound = () => {
    if (notificationSound) {
      console.log('Lecture du son de notification (instance existante)');
      notificationSound.stop();  // Arr√™ter toute lecture pr√©c√©dente
      notificationSound.setVolume(0.7); // Volume mod√©r√©
      notificationSound.play((success) => {
        if (!success) {
          console.log('Erreur lors de la lecture du son de notification');
        } else {
          console.log('Son de notification jou√© avec succ√®s');
        }
      });
    } else {
      console.log('Cr√©ation d\'une nouvelle instance pour le son de notification');
      try {
        const soundName = Platform.OS === 'android' ? 'message_notification.mp3' : 'message_notification.mp3';
        const sound = new Sound(soundName, Sound.MAIN_BUNDLE, (error) => {
          if (error) {
            console.log(`Erreur lors du chargement direct du son de notification (${soundName}):`, error);
            return;
          }
          
          console.log('Son de notification charg√© directement avec succ√®s, lecture');
          sound.setVolume(0.7);
          sound.play((success) => {
            console.log('Lecture directe du son de notification:', success ? 'r√©ussie' : '√©chou√©e');
          });
          // Conserver cette instance pour les prochaines utilisations
          setNotificationSound(sound);
        });
      } catch (e) {
        console.log('Exception lors de la cr√©ation du son de notification:', e);
      }
    }
  };

  // Fonction pour envoyer un message
  const sendMessage = () => {
    if (message.trim().length > 0) {
      const newMessage: Message = {
        id: Date.now().toString(),
        text: message,
        sender: 'user',
        timestamp: new Date(),
        sending: true,
      };
      setMessages([...messages, newMessage]);
      setMessage('');
      
      // Simuler l'envoi du message (changement d'√©tat)
      setTimeout(() => {
        setMessages(currentMessages => 
          currentMessages.map(msg => 
            msg.id === newMessage.id 
              ? { ...msg, sending: false, sent: true } 
              : msg
          )
        );
        
        // Simuler la r√©ception du message
        setTimeout(() => {
          setMessages(currentMessages => 
            currentMessages.map(msg => 
              msg.id === newMessage.id 
                ? { ...msg, received: true } 
                : msg
            )
          );
          
          // Simuler la lecture du message
          setTimeout(() => {
            setMessages(currentMessages => 
              currentMessages.map(msg => 
                msg.id === newMessage.id 
                  ? { ...msg, read: true } 
                  : msg
              )
            );
          }, 2000);
        }, 1000);
      }, 1000);
      
      // Simuler une r√©ponse du contact apr√®s 3 secondes
      setTimeout(() => {
        const responseMessage: Message = {
          id: (Date.now() + 1).toString(),
          text: 'Je viens de recevoir ton message !',
          sender: 'contact',
          timestamp: new Date(),
          sent: true,
          received: true,
        };
        setMessages(currentMessages => [...currentMessages, responseMessage]);
        
        // Jouer le son de notification pour le message re√ßu
        playMessageNotificationSound();
      }, 3000);
    }
  };
  
  // Fonction pour envoyer un fichier (simul√©e)
  const sendFile = () => {
    const newMessage: Message = {
      id: Date.now().toString(),
      text: 'document.pdf',
      sender: 'user',
      timestamp: new Date(),
      isFile: true,
      fileName: 'document.pdf',
      fileSize: '2.8 MB',
      isHighQuality: true,
      sending: true,
    };
    setMessages([...messages, newMessage]);
    
    // Simuler l'envoi du fichier (plus lent qu'un message)
    setTimeout(() => {
      setMessages(currentMessages => 
        currentMessages.map(msg => 
          msg.id === newMessage.id 
            ? { ...msg, sending: false, sent: true } 
            : msg
        )
      );
      
      // Simuler la r√©ception du fichier
      setTimeout(() => {
        setMessages(currentMessages => 
          currentMessages.map(msg => 
            msg.id === newMessage.id 
              ? { ...msg, received: true } 
              : msg
          )
        );
      }, 2000);
    }, 3000);
  };
  
  // Fonction Orb (anciennement Axiom Vibe)
  const sendOrb = () => {
    const now = Date.now();
    const COOLDOWN_PERIOD = 5000; // 5 secondes entre chaque orb
    const MAX_ORBS = 3; // Maximum 3 orbs cons√©cutifs
    
    if (now - lastVibeTime < COOLDOWN_PERIOD && vibeCount >= MAX_ORBS) {
      // Limiter l'utilisation excessive
      return;
    }
    
    // Mettre √† jour les compteurs
    setLastVibeTime(now);
    setVibeCount(prevCount => prevCount + 1);
    
    // Envoyer un Vibe avec vibration - pattern plus perceptible
    Vibration.vibrate([0, 100, 50, 100, 50, 100]);
    
    // Jouer le son de Vibe
    if (vibeSound) {
      console.log('Lecture du son Orb (instance existante)');
      vibeSound.stop(); // Arr√™ter toute lecture pr√©c√©dente
      vibeSound.setVolume(1.0); // S'assurer que le volume est au maximum
      vibeSound.play((success) => {
        if (!success) {
          console.log('Erreur lors de la lecture du son Vibe:', success);
        } else {
          console.log('Son Vibe jou√© avec succ√®s');
        }
      });
    } else {
      console.log('Cr√©ation d\'une nouvelle instance de son pour Orb');
      // Essayer de cr√©er et lire le son directement
      try {
        const soundName = Platform.OS === 'android' ? 'orb.mp3' : 'orb.mp3';
        const sound = new Sound(soundName, Sound.MAIN_BUNDLE, (error) => {
          if (error) {
            console.log(`Erreur lors du chargement direct du son (${soundName}):`, error);
            
            // Essayer sans extension sur Android
            if (Platform.OS === 'android') {
              const altSound = new Sound('orb', Sound.MAIN_BUNDLE, (error2) => {
                if (error2) {
                  console.log('Erreur lors du chargement direct sans extension:', error2);
                } else {
                  altSound.play((success) => {
                    console.log('Lecture directe du son (sans extension):', success ? 'r√©ussie' : '√©chou√©e');
                  });
                  // Conserver cette instance pour les prochaines utilisations
                  setVibeSound(altSound);
                }
              });
            }
            return;
          }
          
          sound.setVolume(1.0);
          sound.play((success) => {
            console.log('Lecture directe du son:', success ? 'r√©ussie' : '√©chou√©e');
          });
          // Conserver cette instance pour les prochaines utilisations
          setVibeSound(sound);
        });
      } catch (e) {
        console.log('Exception lors de la cr√©ation du son:', e);
      }
    }
    
    // Animer la fen√™tre enti√®re
    Animated.sequence([
      Animated.timing(windowAnimatedValue, {
        toValue: 5,
        duration: 50,
        useNativeDriver: true,
      }),
      Animated.timing(windowAnimatedValue, {
        toValue: -5,
        duration: 100,
        useNativeDriver: true,
      }),
      Animated.timing(windowAnimatedValue, {
        toValue: 5,
        duration: 100,
        useNativeDriver: true,
      }),
      Animated.timing(windowAnimatedValue, {
        toValue: 0,
        duration: 50,
        useNativeDriver: true,
      }),
    ]).start();
    
    // Animer la liste des messages
    Animated.sequence([
      Animated.timing(animatedValue, {
        toValue: 10,
        duration: 50,
        useNativeDriver: true,
      }),
      Animated.timing(animatedValue, {
        toValue: -10,
        duration: 100,
        useNativeDriver: true,
      }),
      Animated.timing(animatedValue, {
        toValue: 10,
        duration: 100,
        useNativeDriver: true,
      }),
      Animated.timing(animatedValue, {
        toValue: 0,
        duration: 50,
        useNativeDriver: true,
      }),
    ]).start();
    
    // Mettre √† jour l'√©tat du Vibe
    if (now - lastVibeTime < COOLDOWN_PERIOD) {
      setVibeCount(vibeCount + 1);
    } else {
      setVibeCount(1);
    }
    setLastVibeTime(now);
    
    // Ajouter un message syst√®me pour indiquer l'Orb
    const vibeMessage: Message = {
      id: Date.now().toString(),
      text: 'Vous avez envoy√© un Orb',
      sender: 'user',
      timestamp: new Date(),
      sent: true,
      received: true,
    };
    setMessages([...messages, vibeMessage]);
  };

  const formatTime = (date: Date) => {
    return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
  };

  const renderMessage = ({ item }: { item: Message }) => {
    return (
      <View style={[
        styles.messageBubble,
        item.sender === 'user' ? styles.userBubble : styles.contactBubble,
        item.isFile && styles.fileBubble
      ]}>
        {item.isFile ? (
          // Rendu d'un fichier
          <View style={styles.fileContainer}>
            <Text style={styles.fileIcon}>üìÅ</Text>
            <View style={styles.fileInfo}>
              <Text style={styles.fileName}>{item.fileName}</Text>
              <View style={styles.fileDetails}>
                <Text style={styles.fileSize}>{item.fileSize}</Text>
                {item.isHighQuality && (
                  <View style={styles.hqBadge}>
                    <Text style={styles.hqBadgeText}>HQ</Text>
                  </View>
                )}
              </View>
            </View>
          </View>
        ) : (
          // Rendu d'un message texte normal
          <Text style={styles.messageText}>{item.text}</Text>
        )}
        
        {/* Affichage de l'heure et des indicateurs d'√©tat */}
        <View style={styles.messageFooter}>
          <Text style={styles.messageTime}>{formatTime(item.timestamp)}</Text>
          
          {item.sender === 'user' && (
            <View style={styles.messageStatus}>
              {item.sending && <ActivityIndicator size="small" color="#0084FF" style={styles.statusIcon} />}
              {item.sent && !item.received && <Text style={styles.statusIcon}>‚úì</Text>}
              {item.received && !item.read && <Text style={styles.statusIcon}>‚úì‚úì</Text>}
              {item.read && <Text style={[styles.statusIcon, styles.readStatus]}>‚úì‚úì</Text>}
            </View>
          )}
        </View>
      </View>
    );
  };

  return (
    <Animated.View
      style={[
        styles.container,
        { transform: [{ translateX: windowAnimatedValue }] }
      ]}
    >
      <KeyboardAvoidingView
        behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
        style={styles.innerContainer}
      >
        <View style={styles.header}>
          <Text style={styles.headerTitle}>Contact</Text>
          <Text style={styles.securityInfo}>üîí Chiffrement de bout en bout activ√©</Text>
        </View>
        
        <Animated.View 
          style={[
            styles.messagesListContainer,
            { transform: [{ translateX: animatedValue }] }
          ]}
        >
          <FlatList
            ref={listRef}
            data={messages}
            renderItem={renderMessage}
            keyExtractor={(item) => item.id}
            style={styles.messagesList}
            contentContainerStyle={styles.messagesContainer}
            onContentSizeChange={() => listRef.current?.scrollToEnd({ animated: true })}
            onLayout={() => listRef.current?.scrollToEnd({ animated: true })}
          />
        </Animated.View>
        
        <View style={styles.inputContainer}>
          <View style={styles.buttonsContainer}>
            <TouchableOpacity style={styles.button} onPress={sendOrb}>
              <Text style={styles.buttonText}>üì≥</Text>
            </TouchableOpacity>
            <TouchableOpacity style={styles.button} onPress={sendFile}>
              <Text style={styles.buttonText}>üìé</Text>
            </TouchableOpacity>
          </View>
          
          <TextInput
            style={styles.input}
            placeholder="√âcrivez un message..."
            value={message}
            onChangeText={setMessage}
            multiline
          />
          <TouchableOpacity 
            style={[styles.sendButton, !message.trim() && styles.disabledButton]} 
            onPress={sendMessage}
            disabled={!message.trim()}
          >
            <Text style={styles.sendButtonText}>‚û§</Text>
          </TouchableOpacity>
        </View>
      </KeyboardAvoidingView>
    </Animated.View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f5f5f5',
  },
  innerContainer: {
    flex: 1,
  },
  header: {
    padding: 10,
    backgroundColor: '#fff',
    borderBottomWidth: 1,
    borderBottomColor: '#ddd',
    alignItems: 'center',
  },
  headerTitle: {
    fontSize: 18,
    fontWeight: 'bold',
  },
  securityInfo: {
    fontSize: 12,
    color: 'green',
  },
  messagesList: {
    flex: 1,
    padding: 10,
  },
  messagesContainer: {
    paddingBottom: 10,
  },
  messageBubble: {
    maxWidth: '80%',
    padding: 10,
    borderRadius: 15,
    marginVertical: 5,
  },
  userBubble: {
    backgroundColor: '#DCF8C6',
    alignSelf: 'flex-end',
    marginLeft: '15%',
    borderBottomRightRadius: 0,
  },
  contactBubble: {
    backgroundColor: '#fff',
    alignSelf: 'flex-start',
    marginRight: '15%',
    borderBottomLeftRadius: 0,
  },
  fileBubble: {
    padding: 5,
    paddingVertical: 10,
  },
  fileContainer: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  fileIcon: {
    fontSize: 30,
    marginRight: 10,
  },
  fileInfo: {
    flex: 1,
  },
  fileName: {
    fontSize: 14,
    fontWeight: 'bold',
    marginBottom: 5,
  },
  fileDetails: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  fileSize: {
    fontSize: 12,
    color: '#888',
    marginRight: 10,
  },
  hqBadge: {
    backgroundColor: '#0084FF',
    borderRadius: 8,
    padding: 2,
    paddingHorizontal: 4,
  },
  hqBadgeText: {
    color: 'white',
    fontSize: 8,
    fontWeight: 'bold',
  },
  messageText: {
    fontSize: 16,
  },
  messageFooter: {
    flexDirection: 'row',
    justifyContent: 'flex-end',
    alignItems: 'center',
    marginTop: 5,
  },
  messageTime: {
    fontSize: 10,
    color: '#888',
    marginRight: 5,
  },
  messageStatus: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  statusIcon: {
    fontSize: 12,
    color: '#888',
    marginLeft: 2,
  },
  readStatus: {
    color: '#0084FF',
  },
  messagesListContainer: {
    flex: 1,
  },
  inputContainer: {
    flexDirection: 'row',
    padding: 10,
    backgroundColor: '#fff',
    borderTopWidth: 1,
    borderTopColor: '#ddd',
    alignItems: 'center',
  },
  buttonsContainer: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  button: {
    marginRight: 10,
    padding: 5,
  },
  buttonText: {
    fontSize: 20,
  },
  input: {
    flex: 1,
    backgroundColor: '#f0f0f0',
    borderRadius: 20,
    padding: 10,
    maxHeight: 100,
  },
  sendButton: {
    backgroundColor: '#0084FF',
    width: 40,
    height: 40,
    borderRadius: 20,
    justifyContent: 'center',
    alignItems: 'center',
    marginLeft: 10,
  },
  sendButtonText: {
    color: 'white',
    fontWeight: 'bold',
  },
  disabledButton: {
    backgroundColor: '#cccccc',
  },
});

export default ConversationScreen;
